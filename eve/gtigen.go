// Code generated by "goki generate"; DO NOT EDIT.

package eve

import (
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/mat32/v2"
	"goki.dev/ordmap"
)

// BodyBaseType is the [gti.Type] for [BodyBase]
var BodyBaseType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.BodyBase",
	ShortName:  "eve.BodyBase",
	IDName:     "body-base",
	Doc:        "BodyBase is the base type for all specific Body types",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Rigid", &gti.Field{Name: "Rigid", Type: "github.com/emer/eve/v2/eve.Rigid", LocalType: "Rigid", Doc: "rigid body properties, including mass, bounce, friction etc", Directives: gti.Directives{}, Tag: "desc:\"rigid body properties, including mass, bounce, friction etc\""}},
		{"Vis", &gti.Field{Name: "Vis", Type: "string", LocalType: "string", Doc: "visualization name -- looks up an entry in the scene library that provides the visual representation of this body", Directives: gti.Directives{}, Tag: "desc:\"visualization name -- looks up an entry in the scene library that provides the visual representation of this body\""}},
		{"Color", &gti.Field{Name: "Color", Type: "string", LocalType: "string", Doc: "default color of body for basic InitLibrary configuration", Directives: gti.Directives{}, Tag: "desc:\"default color of body for basic InitLibrary configuration\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "github.com/emer/eve/v2/eve.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &BodyBase{},
})

// NewBodyBase adds a new [BodyBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewBodyBase(par ki.Ki, name ...string) *BodyBase {
	return par.NewChild(BodyBaseType, name...).(*BodyBase)
}

// KiType returns the [*gti.Type] of [BodyBase]
func (t *BodyBase) KiType() *gti.Type {
	return BodyBaseType
}

// New returns a new [*BodyBase] value
func (t *BodyBase) New() ki.Ki {
	return &BodyBase{}
}

// SetRigid sets the [BodyBase.Rigid]:
// rigid body properties, including mass, bounce, friction etc
func (t *BodyBase) SetRigid(v Rigid) *BodyBase {
	t.Rigid = v
	return t
}

// SetVis sets the [BodyBase.Vis]:
// visualization name -- looks up an entry in the scene library that provides the visual representation of this body
func (t *BodyBase) SetVis(v string) *BodyBase {
	t.Vis = v
	return t
}

// SetColor sets the [BodyBase.Color]:
// default color of body for basic InitLibrary configuration
func (t *BodyBase) SetColor(v string) *BodyBase {
	t.Color = v
	return t
}

// SetInitial sets the [BodyBase.Initial]
func (t *BodyBase) SetInitial(v Phys) *BodyBase {
	t.Initial = v
	return t
}

// SetRel sets the [BodyBase.Rel]
func (t *BodyBase) SetRel(v Phys) *BodyBase {
	t.Rel = v
	return t
}

// SetAbs sets the [BodyBase.Abs]
func (t *BodyBase) SetAbs(v Phys) *BodyBase {
	t.Abs = v
	return t
}

// SetBbox sets the [BodyBase.BBox]
func (t *BodyBase) SetBbox(v BBox) *BodyBase {
	t.BBox = v
	return t
}

// BoxType is the [gti.Type] for [Box]
var BoxType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.Box",
	ShortName:  "eve.Box",
	IDName:     "box",
	Doc:        "Box is a box body shape",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "goki.dev/mat32/v2.Vec3", LocalType: "mat32.Vec3", Doc: "size of box in each dimension (units arbitrary, as long as they are all consistent -- meters is typical)", Directives: gti.Directives{}, Tag: "desc:\"size of box in each dimension (units arbitrary, as long as they are all consistent -- meters is typical)\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BodyBase", &gti.Field{Name: "BodyBase", Type: "github.com/emer/eve/v2/eve.BodyBase", LocalType: "BodyBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Box{},
})

// NewBox adds a new [Box] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewBox(par ki.Ki, name ...string) *Box {
	return par.NewChild(BoxType, name...).(*Box)
}

// KiType returns the [*gti.Type] of [Box]
func (t *Box) KiType() *gti.Type {
	return BoxType
}

// New returns a new [*Box] value
func (t *Box) New() ki.Ki {
	return &Box{}
}

// SetSize sets the [Box.Size]:
// size of box in each dimension (units arbitrary, as long as they are all consistent -- meters is typical)
func (t *Box) SetSize(v mat32.Vec3) *Box {
	t.Size = v
	return t
}

// SetInitial sets the [Box.Initial]
func (t *Box) SetInitial(v Phys) *Box {
	t.Initial = v
	return t
}

// SetRel sets the [Box.Rel]
func (t *Box) SetRel(v Phys) *Box {
	t.Rel = v
	return t
}

// SetAbs sets the [Box.Abs]
func (t *Box) SetAbs(v Phys) *Box {
	t.Abs = v
	return t
}

// SetBbox sets the [Box.BBox]
func (t *Box) SetBbox(v BBox) *Box {
	t.BBox = v
	return t
}

// SetRigid sets the [Box.Rigid]
func (t *Box) SetRigid(v Rigid) *Box {
	t.Rigid = v
	return t
}

// SetVis sets the [Box.Vis]
func (t *Box) SetVis(v string) *Box {
	t.Vis = v
	return t
}

// SetColor sets the [Box.Color]
func (t *Box) SetColor(v string) *Box {
	t.Color = v
	return t
}

// CapsuleType is the [gti.Type] for [Capsule]
var CapsuleType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.Capsule",
	ShortName:  "eve.Capsule",
	IDName:     "capsule",
	Doc:        "Capsule is a generalized cylinder body shape, with hemispheres at each end,\nwith separate radii for top and bottom.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder portion of the capsule", Directives: gti.Directives{}, Tag: "desc:\"height of the cylinder portion of the capsule\""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top hemisphere", Directives: gti.Directives{}, Tag: "desc:\"radius of the top hemisphere\""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom hemisphere", Directives: gti.Directives{}, Tag: "desc:\"radius of the bottom hemisphere\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BodyBase", &gti.Field{Name: "BodyBase", Type: "github.com/emer/eve/v2/eve.BodyBase", LocalType: "BodyBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Capsule{},
})

// NewCapsule adds a new [Capsule] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewCapsule(par ki.Ki, name ...string) *Capsule {
	return par.NewChild(CapsuleType, name...).(*Capsule)
}

// KiType returns the [*gti.Type] of [Capsule]
func (t *Capsule) KiType() *gti.Type {
	return CapsuleType
}

// New returns a new [*Capsule] value
func (t *Capsule) New() ki.Ki {
	return &Capsule{}
}

// SetHeight sets the [Capsule.Height]:
// height of the cylinder portion of the capsule
func (t *Capsule) SetHeight(v float32) *Capsule {
	t.Height = v
	return t
}

// SetTopRad sets the [Capsule.TopRad]:
// radius of the top hemisphere
func (t *Capsule) SetTopRad(v float32) *Capsule {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Capsule.BotRad]:
// radius of the bottom hemisphere
func (t *Capsule) SetBotRad(v float32) *Capsule {
	t.BotRad = v
	return t
}

// SetInitial sets the [Capsule.Initial]
func (t *Capsule) SetInitial(v Phys) *Capsule {
	t.Initial = v
	return t
}

// SetRel sets the [Capsule.Rel]
func (t *Capsule) SetRel(v Phys) *Capsule {
	t.Rel = v
	return t
}

// SetAbs sets the [Capsule.Abs]
func (t *Capsule) SetAbs(v Phys) *Capsule {
	t.Abs = v
	return t
}

// SetBbox sets the [Capsule.BBox]
func (t *Capsule) SetBbox(v BBox) *Capsule {
	t.BBox = v
	return t
}

// SetRigid sets the [Capsule.Rigid]
func (t *Capsule) SetRigid(v Rigid) *Capsule {
	t.Rigid = v
	return t
}

// SetVis sets the [Capsule.Vis]
func (t *Capsule) SetVis(v string) *Capsule {
	t.Vis = v
	return t
}

// SetColor sets the [Capsule.Color]
func (t *Capsule) SetColor(v string) *Capsule {
	t.Color = v
	return t
}

// CylinderType is the [gti.Type] for [Cylinder]
var CylinderType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.Cylinder",
	ShortName:  "eve.Cylinder",
	IDName:     "cylinder",
	Doc:        "Cylinder is a generalized cylinder body shape, with separate radii for top and bottom.\nA cone has a zero radius at one end.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Height", &gti.Field{Name: "Height", Type: "float32", LocalType: "float32", Doc: "height of the cylinder", Directives: gti.Directives{}, Tag: "desc:\"height of the cylinder\""}},
		{"TopRad", &gti.Field{Name: "TopRad", Type: "float32", LocalType: "float32", Doc: "radius of the top -- set to 0 for a cone", Directives: gti.Directives{}, Tag: "desc:\"radius of the top -- set to 0 for a cone\""}},
		{"BotRad", &gti.Field{Name: "BotRad", Type: "float32", LocalType: "float32", Doc: "radius of the bottom", Directives: gti.Directives{}, Tag: "desc:\"radius of the bottom\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BodyBase", &gti.Field{Name: "BodyBase", Type: "github.com/emer/eve/v2/eve.BodyBase", LocalType: "BodyBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Cylinder{},
})

// NewCylinder adds a new [Cylinder] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewCylinder(par ki.Ki, name ...string) *Cylinder {
	return par.NewChild(CylinderType, name...).(*Cylinder)
}

// KiType returns the [*gti.Type] of [Cylinder]
func (t *Cylinder) KiType() *gti.Type {
	return CylinderType
}

// New returns a new [*Cylinder] value
func (t *Cylinder) New() ki.Ki {
	return &Cylinder{}
}

// SetHeight sets the [Cylinder.Height]:
// height of the cylinder
func (t *Cylinder) SetHeight(v float32) *Cylinder {
	t.Height = v
	return t
}

// SetTopRad sets the [Cylinder.TopRad]:
// radius of the top -- set to 0 for a cone
func (t *Cylinder) SetTopRad(v float32) *Cylinder {
	t.TopRad = v
	return t
}

// SetBotRad sets the [Cylinder.BotRad]:
// radius of the bottom
func (t *Cylinder) SetBotRad(v float32) *Cylinder {
	t.BotRad = v
	return t
}

// SetInitial sets the [Cylinder.Initial]
func (t *Cylinder) SetInitial(v Phys) *Cylinder {
	t.Initial = v
	return t
}

// SetRel sets the [Cylinder.Rel]
func (t *Cylinder) SetRel(v Phys) *Cylinder {
	t.Rel = v
	return t
}

// SetAbs sets the [Cylinder.Abs]
func (t *Cylinder) SetAbs(v Phys) *Cylinder {
	t.Abs = v
	return t
}

// SetBbox sets the [Cylinder.BBox]
func (t *Cylinder) SetBbox(v BBox) *Cylinder {
	t.BBox = v
	return t
}

// SetRigid sets the [Cylinder.Rigid]
func (t *Cylinder) SetRigid(v Rigid) *Cylinder {
	t.Rigid = v
	return t
}

// SetVis sets the [Cylinder.Vis]
func (t *Cylinder) SetVis(v string) *Cylinder {
	t.Vis = v
	return t
}

// SetColor sets the [Cylinder.Color]
func (t *Cylinder) SetColor(v string) *Cylinder {
	t.Color = v
	return t
}

// GroupType is the [gti.Type] for [Group]
var GroupType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.Group",
	ShortName:  "eve.Group",
	IDName:     "group",
	Doc:        "Group is a container of bodies, joints, or other groups\nit should be used strategically to partition the space\nand its BBox is used to optimize tree-based collision detection.\nUse a group for the top-level World node as well.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NodeBase", &gti.Field{Name: "NodeBase", Type: "github.com/emer/eve/v2/eve.NodeBase", LocalType: "NodeBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Group{},
})

// NewGroup adds a new [Group] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewGroup(par ki.Ki, name ...string) *Group {
	return par.NewChild(GroupType, name...).(*Group)
}

// KiType returns the [*gti.Type] of [Group]
func (t *Group) KiType() *gti.Type {
	return GroupType
}

// New returns a new [*Group] value
func (t *Group) New() ki.Ki {
	return &Group{}
}

// SetInitial sets the [Group.Initial]
func (t *Group) SetInitial(v Phys) *Group {
	t.Initial = v
	return t
}

// SetRel sets the [Group.Rel]
func (t *Group) SetRel(v Phys) *Group {
	t.Rel = v
	return t
}

// SetAbs sets the [Group.Abs]
func (t *Group) SetAbs(v Phys) *Group {
	t.Abs = v
	return t
}

// SetBbox sets the [Group.BBox]
func (t *Group) SetBbox(v BBox) *Group {
	t.BBox = v
	return t
}

// NodeBaseType is the [gti.Type] for [NodeBase]
var NodeBaseType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.NodeBase",
	ShortName:  "eve.NodeBase",
	IDName:     "node-base",
	Doc:        "NodeBase is the basic eve node, which has position, rotation, velocity\nand computed bounding boxes, etc.\nThere are only three different kinds of Nodes: Group, Body, and Joint",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Initial", &gti.Field{Name: "Initial", Type: "github.com/emer/eve/v2/eve.Phys", LocalType: "Phys", Doc: "[view: inline] initial position, orientation, velocity in *local* coordinates (relative to parent)", Directives: gti.Directives{}, Tag: "view:\"inline\" desc:\"initial position, orientation, velocity in *local* coordinates (relative to parent)\""}},
		{"Rel", &gti.Field{Name: "Rel", Type: "github.com/emer/eve/v2/eve.Phys", LocalType: "Phys", Doc: "[view: inline] current relative (local) position, orientation, velocity -- only change these values, as abs values are computed therefrom", Directives: gti.Directives{}, Tag: "view:\"inline\" desc:\"current relative (local) position, orientation, velocity -- only change these values, as abs values are computed therefrom\""}},
		{"Abs", &gti.Field{Name: "Abs", Type: "github.com/emer/eve/v2/eve.Phys", LocalType: "Phys", Doc: "[view: inline] current absolute (world) position, orientation, velocity", Directives: gti.Directives{}, Tag: "inactive:\"+\" view:\"inline\" desc:\"current absolute (world) position, orientation, velocity\""}},
		{"BBox", &gti.Field{Name: "BBox", Type: "github.com/emer/eve/v2/eve.BBox", LocalType: "BBox", Doc: "bounding box in world coordinates (aggregated for groups)", Directives: gti.Directives{}, Tag: "desc:\"bounding box in world coordinates (aggregated for groups)\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Node", &gti.Field{Name: "Node", Type: "goki.dev/ki/v2.Node", LocalType: "ki.Node", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &NodeBase{},
})

// NewNodeBase adds a new [NodeBase] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNodeBase(par ki.Ki, name ...string) *NodeBase {
	return par.NewChild(NodeBaseType, name...).(*NodeBase)
}

// KiType returns the [*gti.Type] of [NodeBase]
func (t *NodeBase) KiType() *gti.Type {
	return NodeBaseType
}

// New returns a new [*NodeBase] value
func (t *NodeBase) New() ki.Ki {
	return &NodeBase{}
}

// SetInitial sets the [NodeBase.Initial]:
// [view: inline] initial position, orientation, velocity in *local* coordinates (relative to parent)
func (t *NodeBase) SetInitial(v Phys) *NodeBase {
	t.Initial = v
	return t
}

// SetRel sets the [NodeBase.Rel]:
// [view: inline] current relative (local) position, orientation, velocity -- only change these values, as abs values are computed therefrom
func (t *NodeBase) SetRel(v Phys) *NodeBase {
	t.Rel = v
	return t
}

// SetAbs sets the [NodeBase.Abs]:
// [view: inline] current absolute (world) position, orientation, velocity
func (t *NodeBase) SetAbs(v Phys) *NodeBase {
	t.Abs = v
	return t
}

// SetBbox sets the [NodeBase.BBox]:
// bounding box in world coordinates (aggregated for groups)
func (t *NodeBase) SetBbox(v BBox) *NodeBase {
	t.BBox = v
	return t
}

// SphereType is the [gti.Type] for [Sphere]
var SphereType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/eve/v2/eve.Sphere",
	ShortName:  "eve.Sphere",
	IDName:     "sphere",
	Doc:        "Sphere is a spherical body shape.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "float32", LocalType: "float32", Doc: "radius", Directives: gti.Directives{}, Tag: "desc:\"radius\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"BodyBase", &gti.Field{Name: "BodyBase", Type: "github.com/emer/eve/v2/eve.BodyBase", LocalType: "BodyBase", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &Sphere{},
})

// NewSphere adds a new [Sphere] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewSphere(par ki.Ki, name ...string) *Sphere {
	return par.NewChild(SphereType, name...).(*Sphere)
}

// KiType returns the [*gti.Type] of [Sphere]
func (t *Sphere) KiType() *gti.Type {
	return SphereType
}

// New returns a new [*Sphere] value
func (t *Sphere) New() ki.Ki {
	return &Sphere{}
}

// SetRadius sets the [Sphere.Radius]:
// radius
func (t *Sphere) SetRadius(v float32) *Sphere {
	t.Radius = v
	return t
}

// SetInitial sets the [Sphere.Initial]
func (t *Sphere) SetInitial(v Phys) *Sphere {
	t.Initial = v
	return t
}

// SetRel sets the [Sphere.Rel]
func (t *Sphere) SetRel(v Phys) *Sphere {
	t.Rel = v
	return t
}

// SetAbs sets the [Sphere.Abs]
func (t *Sphere) SetAbs(v Phys) *Sphere {
	t.Abs = v
	return t
}

// SetBbox sets the [Sphere.BBox]
func (t *Sphere) SetBbox(v BBox) *Sphere {
	t.BBox = v
	return t
}

// SetRigid sets the [Sphere.Rigid]
func (t *Sphere) SetRigid(v Rigid) *Sphere {
	t.Rigid = v
	return t
}

// SetVis sets the [Sphere.Vis]
func (t *Sphere) SetVis(v string) *Sphere {
	t.Vis = v
	return t
}

// SetColor sets the [Sphere.Color]
func (t *Sphere) SetColor(v string) *Sphere {
	t.Color = v
	return t
}
